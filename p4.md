1️⃣ Goal

Automatically create (or update) Jira issues whenever something happens in a GitHub repository—
for example, when a new comment with a special keyword appears on an issue or pull request.

2️⃣ High-Level Flow
GitHub Event  ──►  Flask Webhook Endpoint  ──►  Jira REST API
      (push, issue comment, etc.)            (create/transition issue)


GitHub sends a webhook:
When an event occurs (e.g., a new comment), GitHub POSTs a JSON payload to a public URL you control.

Flask receives and parses it:
Your Flask app exposes a route (like /createjira) that reads the JSON and decides what to do.

Create/Update Jira issue:
If the payload meets your criteria (for example, comment body contains /jira.com), you call Jira’s REST API to create or transition an issue.

3️⃣ Setting It Up
a. Jira Side

Create an API token (Atlassian account → Account settings → Security → API tokens).

Note your Jira base URL, e.g. https://<your-domain>.atlassian.net.

Identify the project key (e.g. PROJ) and issue type (Bug, Task, etc.).

b. GitHub Side

Go to your repo → Settings → Webhooks → Add webhook.

Payload URL: public URL of your Flask server (https://yourserver/createjira).

Content type: application/json.

Select the events you care about (e.g. Issue comments).

c. Flask Server

A minimal pattern:

from flask import Flask, request, jsonify
import requests
from requests.auth import HTTPBasicAuth
import json, os

app = Flask(__name__)

@app.route("/createjira", methods=["POST"])
def create_jira():
    git_data = request.get_json()
    comment = git_data.get("comment", {}).get("body", "")

    # Only trigger if a special keyword is present
    if "/jira.com" not in comment:
        return "No action", 200

    jira_url = "https://<your-domain>.atlassian.net/rest/api/3/issue"
    auth = HTTPBasicAuth(os.getenv("JIRA_EMAIL"), os.getenv("JIRA_API_TOKEN"))
    headers = {"Content-Type": "application/json"}

    payload = {
        "fields": {
            "project": {"key": "PROJ"},
            "summary": git_data["issue"]["title"],
            "description": git_data["issue"]["body"],
            "issuetype": {"name": "Bug"}
        }
    }

    r = requests.post(jira_url, headers=headers, auth=auth, json=payload)
    return jsonify(r.json()), r.status_code


Key Points

Use methods=["POST"] (not method).

Secure your credentials—load from environment variables, never hard-code.

4️⃣ Deployment

The Flask app must be reachable from GitHub:

Deploy on a public server (cloud VM, container platform, or behind a reverse proxy with HTTPS).

If developing locally, use a tunnel like ngrok to expose it.

Run it as a service so it survives SSH disconnects (systemd unit, Docker container, etc.).

5️⃣ Security Considerations

Verify GitHub’s signature:
GitHub can sign payloads with a secret you set in the webhook.
Validate the X-Hub-Signature-256 header to ensure requests are genuine.

Never log or commit your Jira token.

Rate-limit or authenticate if you expose more endpoints.

6️⃣ Typical Use Cases

Automatically create Jira tickets from GitHub issues or PR comments.

Synchronize labels, status changes, or assignee updates.

Post back to GitHub with the created Jira issue link.

Summary

GitHub Jira integration with Python/Flask is essentially:

Webhook listener (Flask) to capture GitHub events.

REST client (requests) to talk to Jira.

Deployed as a persistent service with proper authentication and security.

This gives you full control—you decide which events create issues, how fields are mapped, and any custom automation logic.
